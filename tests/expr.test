#!/bin/bash

[ -f testing.sh ] && . testing.sh

testing "integer" "expr 5" "5\n" "" ""
testing "integer negative" "expr -5" "-5\n" "" ""
testing "string" "expr astring" "astring\n" "" ""
testing "1 + 3" "expr 1 + 3" "4\n" "" ""
testing "5 + 6 * 3" "expr 5 + 6 \* 3" "23\n" "" ""
testing "( 5 + 6 ) * 3" "expr \( 5 + 6 \) \* 3" "33\n" "" ""
testing "* / same priority" "expr 4 \* 3 / 2"  "6\n" "" ""
testing "/ * same priority" "expr 3 / 2 \* 4" "4\n" "" ""
testing "& before |" "expr 0 \| 1 \& 0" "0\n" "" ""
testing "| after &" "expr 1 \| 0 \& 0" "1\n" "" ""
testing "| & same priority" "expr 0 \& 0 \| 1" "1\n" "" ""
testing "% * same priority" "expr 3 % 2 \* 4" "4\n" "" ""
testing "* % same priority" "expr 3 \* 2 % 4" "2\n" "" ""
testing "= > same priority" "expr 0 = 2 \> 3" "0\n" "" ""
testing "> = same priority" "expr 3 \> 2 = 1" "1\n" "" ""

# result of ':' regex match can subsequently be used for arithmetic
testing "string becomes integer" "expr ab21xx : '[^0-9]*\([0-9]*\)' + 3" \
	"24\n" "" ""

# BUG: exits early, so gives 2?
testing "exit code when true" "expr a; echo \$?" "a\n0\n" "" ""

testing "exit code when false" "expr 0; echo \$?" "0\n1\n" "" ""

testing "exit code with syntax error" "expr \(; echo \$?" "2\n" "" ""

# BUG: seg fault
testing "regex" "expr 3 : '\(.\)'" "3\n" "" ""

# NOTE: coreutils expr considers no expression a syntax error, so the return
# value is 2 instead of 1.
testing "no expression" "expr; echo \$?" "\n1\n" "" ""
